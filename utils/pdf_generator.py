# utils/pdf_generator.py - ENHANCED WITH COMPREHENSIVE MAPPING

from fpdf import FPDF
import os
import datetime
import matplotlib.pyplot as plt
import numpy as np
import io
import base64
import requests
import tempfile
import json
import matplotlib.patches as mpatches
from matplotlib.patches import Rectangle

class RoutePDF(FPDF):
    def __init__(self, title=None):
        super().__init__()
        self.title = title or "Route Analytics Report"
        self.company_name = "Route Analytics Pro"
        self.set_auto_page_break(auto=True, margin=20)
        
        # Professional color scheme
        self.primary_color = (52, 58, 64)
        self.secondary_color = (108, 117, 125)
        self.accent_color = (32, 107, 196)
        self.danger_color = (220, 53, 69)
        self.warning_color = (253, 126, 20)
        self.success_color = (40, 167, 69)
        
        # Map marker colors for different POI types
        self.marker_colors = {
            'start': 'green',
            'end': 'red',
            'blind_spot': 'darkred',      # >80¬∞ turns
            'sharp_turn': 'red',          # 70-80¬∞ turns
            'moderate_turn': 'orange',    # 45-70¬∞ turns
            'hospital': 'blue',
            'petrol_pump': 'purple',
            'school': 'yellow',
            'food': 'cyan',
            'police': 'black',
            'elevation_high': 'brown',
            'elevation_low': 'lightgreen',
            'network_dead': 'gray',
            'network_poor': 'pink',
            'network_good': 'lightblue'
        }
    
    def add_title_page(self):
        """Professional title page"""
        self.add_page()
        
        # Background
        self.set_fill_color(248, 249, 250)
        self.rect(0, 0, 210, 297, 'F')
        
        # Header section
        self.set_fill_color(*self.primary_color)
        self.rect(0, 0, 210, 80, 'F')
        
        # Company logo/name
        self.set_font('Arial', 'B', 24)
        self.set_text_color(255, 255, 255)
        self.set_xy(20, 25)
        self.cell(0, 15, 'RA', 0, 0, 'L')
        
        self.set_font('Arial', 'B', 18)
        self.set_xy(70, 20)
        self.cell(0, 10, self.company_name, 0, 1, 'L')
        
        self.set_font('Arial', '', 12)
        self.set_xy(70, 32)
        self.cell(0, 8, 'Advanced Route Safety & Analytics with Real-Time Network Data', 0, 1, 'L')
        
        # Report title
        self.set_xy(20, 100)
        self.set_font('Arial', 'B', 28)
        self.set_text_color(*self.primary_color)
        self.multi_cell(170, 15, self.clean_text(self.title), 0, 'C')
        
        # Subtitle
        self.set_xy(20, 140)
        self.set_font('Arial', '', 16)
        self.set_text_color(*self.secondary_color)
        self.cell(170, 10, 'Comprehensive Maps, Network Coverage & Safety Analysis', 0, 1, 'C')
        
        # Report details card
        self.set_xy(40, 170)
        self.set_fill_color(255, 255, 255)
        self.set_draw_color(222, 226, 230)
        self.rect(40, 170, 130, 60, 'DF')
        
        self.set_font('Arial', 'B', 12)
        self.set_text_color(*self.primary_color)
        self.set_xy(50, 180)
        self.cell(0, 8, 'Report Generated:', 0, 1, 'L')
        
        self.set_font('Arial', '', 11)
        self.set_text_color(*self.secondary_color)
        self.set_xy(50, 190)
        now = datetime.datetime.now()
        self.cell(0, 6, now.strftime("%B %d, %Y at %I:%M %p"), 0, 1, 'L')
        
    def header(self):
        if self.page_no() == 1:
            return
            
        self.set_fill_color(*self.primary_color)
        self.rect(0, 0, 210, 25, 'F')
        
        self.set_font('Arial', 'B', 12)
        self.set_text_color(255, 255, 255)
        self.set_xy(15, 8)
        self.cell(0, 8, self.company_name, 0, 0, 'L')
        
        self.set_xy(-40, 8)
        self.cell(0, 8, f'Page {self.page_no()}', 0, 0, 'R')
        
        self.ln(30)
        
    def footer(self):
        self.set_y(-20)
        self.set_draw_color(222, 226, 230)
        self.line(15, self.get_y(), 195, self.get_y())
        
        self.set_font('Arial', 'I', 8)
        self.set_text_color(*self.secondary_color)
        self.set_y(-15)
        self.cell(0, 5, f'Generated by {self.company_name} Route Analytics System', 0, 0, 'C')
        
    def chapter_title(self, title):
        self.set_font('Arial', 'B', 14)
        self.set_fill_color(*self.accent_color)
        self.set_text_color(255, 255, 255)
        self.cell(0, 12, self.clean_text(title), 0, 1, 'L', 1)
        self.ln(4)
        
    def chapter_body(self, body):
        self.set_font('Arial', '', 12)
        self.set_text_color(0, 0, 0)
        try:
            clean_body = self.clean_text(body)
            self.multi_cell(0, 5, clean_body)
        except UnicodeEncodeError:
            clean_body = body.encode('latin-1', 'ignore').decode('latin-1')
            self.multi_cell(0, 5, clean_body)
        self.ln()
    
    def clean_text(self, text):
        """Enhanced text cleaning"""
        if not isinstance(text, str):
            text = str(text)
        
        replacements = {
            '‚ö†': '[WARNING]', 'üö´': '[DANGER]', '‚Ñπ': '[INFO]', '‚úÖ': '[OK]',
            'üöó': '[CAR]', 'üöõ': '[TRUCK]', 'üöå': '[BUS]', '‚õΩ': '[FUEL]',
            'üè•': '[HOSPITAL]', 'üöî': '[POLICE]', 'üå°': '[TEMP]', 'üåß': '[RAIN]',
            '‚òÄ': '[SUN]', '‚ùÑ': '[SNOW]', 'üí®': '[WIND]', '¬∞': 'deg',
            '‚Ä¢': '*', '‚Üí': '->', '‚Üê': '<-', '‚Üë': '^', '‚Üì': 'v',
            '"': '"', '"': '"', ''': "'", ''': "'", '‚Äì': '-', '‚Äî': '-',
            'üîç': '[SEARCH]', 'üîÑ': '[TURN]', 'üó∫Ô∏è': '[MAP]', 'üå§Ô∏è': '[WEATHER]',
            'üõ†Ô∏è': '[TOOLS]', 'üìç': '[LOCATION]', 'üëÅÔ∏è': '[VIEW]'
        }
        
        for unicode_char, ascii_replacement in replacements.items():
            text = text.replace(unicode_char, ascii_replacement)
        
        try:
            text.encode('latin-1')
            return text
        except UnicodeEncodeError:
            return text.encode('latin-1', 'ignore').decode('latin-1')
        
    def add_section(self, title, content):
        clean_title = self.clean_text(title)
        clean_content = self.clean_text(content)
        self.chapter_title(clean_title)
        self.chapter_body(clean_content)
    
    def add_info_card(self, title, content, bg_color=(255, 255, 255)):
        """Professional info card"""
        y_start = self.get_y()
        
        self.set_font('Arial', 'B', 12)
        self.set_text_color(*self.primary_color)
        self.set_xy(20, y_start + 3)
        self.cell(0, 6, self.clean_text(title), 0, 1, 'L')
        
        self.set_font('Arial', '', 10)
        self.set_text_color(*self.secondary_color)
        self.set_xy(20, y_start + 12)
        
        content_lines = self.clean_text(content).split('\n')
        content_height = len(content_lines) * 5 + 15
        
        self.set_fill_color(*bg_color)
        self.set_draw_color(222, 226, 230)
        self.rect(15, y_start, 180, content_height, 'DF')
        
        self.set_xy(20, y_start + 12)
        self.multi_cell(170, 5, self.clean_text(content))
        self.ln(5)

    def add_comprehensive_route_map(self, route_data, api_key=None):
        """ENHANCEMENT 1: Comprehensive route map with ALL points marked with different colors"""
        self.add_page()
        self.chapter_title("COMPREHENSIVE ROUTE MAP - ALL POINTS MARKED")
        
        # Enhanced legend with all marker types
        legend_content = """COMPREHENSIVE ROUTE MAP LEGEND:
    [START] Green: Route start point
    [END] Red: Route destination point
    [EXTREME] Dark Red: Blind spots (>80deg) - EXTREME DANGER
    [DANGER] Red: Sharp turns (70-80deg) - HIGH DANGER
    [CAUTION] Orange: Moderate turns (45-70deg) - CAUTION REQUIRED
    [HOSPITAL] Blue: Hospitals - Emergency medical services
    [FUEL] Purple: Petrol pumps - Fuel stations
    [SCHOOL] Yellow: Schools - Speed limit zones (reduce to 40 km/h)
    [FOOD] Cyan: Restaurants/Food stops - Rest areas
    [POLICE] Black: Police stations - Security services
    [HIGH-ELEV] Brown: High elevation points (>1000m)
    [LOW-ELEV] Light Green: Low elevation points
    [NETWORK-DEAD] Gray: Network dead zones - NO signal
    [NETWORK-POOR] Pink: Poor network coverage
    [NETWORK-GOOD] Light Blue: Good network coverage

    This map shows EVERY analyzed point with color-coded markers for instant
    visual identification of hazards, services, and network coverage."""
        
        self.add_info_card("Comprehensive Map Legend", legend_content, (240, 248, 255))
        
        # Get all data
        route_points = route_data.get('route_points', [])
        sharp_turns = route_data.get('sharp_turns', [])
        elevation_data = route_data.get('elevation', [])
        network_coverage = route_data.get('network_coverage', {})
        pois = {
            'hospitals': route_data.get('hospitals', {}),
            'petrol_bunks': route_data.get('petrol_bunks', {}),  # FIXED: was 'petrel_bunks'
            'schools': route_data.get('schools', {}),
            'food_stops': route_data.get('food_stops', {}),
            'police_stations': route_data.get('police_stations', {})
        }
        
        # Calculate comprehensive statistics
        blind_spots = len([t for t in sharp_turns if t.get('angle', 0) > 80])
        sharp_danger = len([t for t in sharp_turns if 70 <= t.get('angle', 0) <= 80])
        moderate_turns = len([t for t in sharp_turns if 45 <= t.get('angle', 0) < 70])
        
        high_elevations = len([e for e in elevation_data if e.get('elevation', 0) > 1000])
        low_elevations = len([e for e in elevation_data if e.get('elevation', 0) < 500])
        
        dead_zones = len(network_coverage.get('dead_zones', []))
        poor_zones = len(network_coverage.get('poor_zones', []))
        
        total_pois = sum(len(poi_dict) for poi_dict in pois.values())
        
        stats_content = f"""COMPREHENSIVE ROUTE STATISTICS:
    Total Route Points Analyzed: {len(route_points)}
    Total Distance: {route_data.get('distance', 'Unknown')}
    Estimated Duration: {route_data.get('duration', 'Unknown')}

    HAZARD ANALYSIS:
    * Extreme Blind Spots (>80deg): {blind_spots} [Dark Red markers]
    * High-Danger Sharp Turns (70-80deg): {sharp_danger} [Red markers]
    * Moderate Caution Turns (45-70deg): {moderate_turns} [Orange markers]
    Total Hazardous Turns: {len(sharp_turns)}

    ELEVATION ANALYSIS:
    * High Elevation Points (>1000m): {high_elevations} [Brown markers]
    * Low Elevation Points (<500m): {low_elevations} [Light Green markers]
    Total Elevation Points: {len(elevation_data)}

    NETWORK COVERAGE ANALYSIS:
    * Dead Zones (No Signal): {dead_zones} [Gray markers]
    * Poor Coverage Areas: {poor_zones} [Pink markers]
    API Success Rate: {network_coverage.get('coverage_stats', {}).get('api_success_rate', 0):.1f}%

    POINTS OF INTEREST:
    * Hospitals: {len(pois['hospitals'])} [Blue markers]
    * Fuel Stations: {len(pois['petrol_bunks'])} [Purple markers]  # FIXED: was 'petrel_bunks'
    * Schools: {len(pois['schools'])} [Yellow markers]
    * Food Stops: {len(pois['food_stops'])} [Cyan markers]
    * Police Stations: {len(pois['police_stations'])} [Black markers]
    Total POIs: {total_pois}

    SAFETY SCORE: {self.calculate_safety_score(sharp_turns, dead_zones, poor_zones)}/100"""
        
        self.add_info_card("Comprehensive Route Analysis", stats_content)
        
        if api_key and route_points:
            # Create comprehensive markers list
            all_markers = self.create_comprehensive_markers(route_data)
            
            if all_markers:
                # Calculate map center
                center_lat = sum(marker['lat'] for marker in all_markers) / len(all_markers)
                center_lng = sum(marker['lng'] for marker in all_markers) / len(all_markers)
                
                self.set_font('Arial', 'B', 12)
                self.cell(0, 8, "[COMPREHENSIVE MAP] ALL POINTS WITH COLOR-CODED MARKERS:", ln=True)
                self.ln(3)
                
                if self.add_static_map_image(center_lat, center_lng, all_markers, api_key, zoom=10, size="640x480"):
                    self.set_font('Arial', 'I', 10)
                    self.cell(0, 5, f"Comprehensive map showing {len(all_markers)} analyzed points with color-coded markers", ln=True, align='C')
                    
                    # Add detailed marker count breakdown
                    marker_counts = {}
                    for marker in all_markers:
                        marker_type = marker.get('type', 'unknown')
                        marker_counts[marker_type] = marker_counts.get(marker_type, 0) + 1
                    
                    breakdown_text = "Marker Breakdown: " + ", ".join([f"{k.title()}: {v}" for k, v in marker_counts.items()])
                    self.set_font('Arial', 'I', 8)
                    self.multi_cell(0, 4, breakdown_text, align='C')

    def create_comprehensive_markers(self, route_data):
        """Create comprehensive markers for all types of points"""
        markers = []
        route_points = route_data.get('route_points', [])
        
        if not route_points:
            return []
        
        # 1. START AND END POINTS
        markers.extend([
            {
                'lat': route_points[0][0], 'lng': route_points[0][1],
                'color': self.marker_colors['start'], 'label': 'S', 'type': 'start'
            },
            {
                'lat': route_points[-1][0], 'lng': route_points[-1][1],
                'color': self.marker_colors['end'], 'label': 'E', 'type': 'end'
            }
        ])
        
        # 2. SHARP TURNS WITH ANGLE-BASED COLORS
        sharp_turns = route_data.get('sharp_turns', [])
        for i, turn in enumerate(sharp_turns[:25], 1):  # Limit to 25 for map clarity
            angle = turn.get('angle', 0)
            if angle > 80:
                color = self.marker_colors['blind_spot']
                label = f'B{i}'  # Blind spot
                turn_type = 'blind_spot'
            elif angle >= 70:
                color = self.marker_colors['sharp_turn']
                label = f'S{i}'  # Sharp turn
                turn_type = 'sharp_turn'
            else:
                color = self.marker_colors['moderate_turn']
                label = f'M{i}'  # Moderate turn
                turn_type = 'moderate_turn'
            
            markers.append({
                'lat': turn['lat'], 'lng': turn['lng'],
                'color': color, 'label': label, 'type': turn_type,
                'angle': angle
            })
        
        # 3. ELEVATION POINTS
        elevation_data = route_data.get('elevation', [])
        for i, elev in enumerate(elevation_data[:10], 1):  # Limit to 10
            elevation = elev.get('elevation', 0)
            location = elev.get('location', {})
            
            if isinstance(location, dict) and 'lat' in location:
                if elevation > 1000:
                    color = self.marker_colors['elevation_high']
                    label = f'H{i}'
                    elev_type = 'elevation_high'
                else:
                    color = self.marker_colors['elevation_low']
                    label = f'L{i}'
                    elev_type = 'elevation_low'
                
                markers.append({
                    'lat': location['lat'], 'lng': location['lng'],
                    'color': color, 'label': label, 'type': elev_type,
                    'elevation': elevation
                })
        
        # 4. NETWORK COVERAGE POINTS
        network_coverage = route_data.get('network_coverage', {})
        dead_zones = network_coverage.get('dead_zones', [])
        poor_zones = network_coverage.get('poor_zones', [])
        
        # Dead zones (gray markers)
        for i, zone in enumerate(dead_zones[:5], 1):
            coords = self.extract_coordinates(zone)
            if coords:
                markers.append({
                    'lat': coords['lat'], 'lng': coords['lng'],
                    'color': self.marker_colors['network_dead'],
                    'label': f'D{i}', 'type': 'network_dead'
                })
        
        # Poor coverage zones (pink markers)
        for i, zone in enumerate(poor_zones[:3], 1):
            coords = self.extract_coordinates(zone)
            if coords:
                markers.append({
                    'lat': coords['lat'], 'lng': coords['lng'],
                    'color': self.marker_colors['network_poor'],
                    'label': f'P{i}', 'type': 'network_poor'
                })
        
        # 5. POINTS OF INTEREST - Distributed along route
        pois_data = {
            'hospitals': route_data.get('hospitals', {}),
            'petrol_bunks': route_data.get('petrol_bunks', {}),  # FIXED: was 'petrel_bunks'
            'schools': route_data.get('schools', {}),
            'food_stops': route_data.get('food_stops', {}),
            'police_stations': route_data.get('police_stations', {})
        }
        
        poi_markers = self.create_distributed_poi_markers(route_points, pois_data)
        markers.extend(poi_markers)
        
        return markers

    def create_distributed_poi_markers(self, route_points, pois_data):
        """Create POI markers distributed along the route"""
        markers = []
        route_length = len(route_points)
        
        if route_length == 0:
            return markers
        
        # Hospitals (blue markers)
        hospitals = list(pois_data.get('hospitals', {}).keys())[:4]
        for i, hospital in enumerate(hospitals):
            point_index = min(i * (route_length // max(len(hospitals), 1)), route_length - 1)
            point = route_points[point_index]
            markers.append({
                'lat': point[0] + 0.002,  # Slight offset for visibility
                'lng': point[1] + 0.002,
                'color': self.marker_colors['hospital'],
                'label': f'H{i+1}', 'type': 'hospital'
            })
        
        # Petrol pumps (purple markers)
        petrol_bunks = list(pois_data.get('petrol_bunks', {}).keys())[:3]
        for i, station in enumerate(petrol_bunks):
            point_index = min((i + 1) * (route_length // max(len(petrol_bunks) + 1, 1)), route_length - 1)
            point = route_points[point_index]
            markers.append({
                'lat': point[0] - 0.002,
                'lng': point[1] + 0.002,
                'color': self.marker_colors['petrol_pump'],
                'label': f'F{i+1}', 'type': 'petrol_pump'
            })
        
        # Schools (yellow markers)
        schools = list(pois_data.get('schools', {}).keys())[:3]
        for i, school in enumerate(schools):
            point_index = min((i + 2) * (route_length // max(len(schools) + 2, 1)), route_length - 1)
            point = route_points[point_index]
            markers.append({
                'lat': point[0] + 0.001,
                'lng': point[1] - 0.002,
                'color': self.marker_colors['school'],
                'label': f'Sc{i+1}', 'type': 'school'
            })
        
        # Food stops (cyan markers)
        food_stops = list(pois_data.get('food_stops', {}).keys())[:2]
        for i, food in enumerate(food_stops):
            point_index = min((i + 3) * (route_length // max(len(food_stops) + 3, 1)), route_length - 1)
            point = route_points[point_index]
            markers.append({
                'lat': point[0] - 0.001,
                'lng': point[1] - 0.001,
                'color': self.marker_colors['food'],
                'label': f'Fd{i+1}', 'type': 'food'
            })
        
        # Police stations (black markers)
        police_stations = list(pois_data.get('police_stations', {}).keys())[:2]
        for i, police in enumerate(police_stations):
            point_index = min((i + 4) * (route_length // max(len(police_stations) + 4, 1)), route_length - 1)
            point = route_points[point_index]
            markers.append({
                'lat': point[0] + 0.003,
                'lng': point[1] - 0.003,
                'color': self.marker_colors['police'],
                'label': f'Pl{i+1}', 'type': 'police'
            })
        
        return markers

    def add_dedicated_network_coverage_map(self, route_data, api_key=None):
        """ENHANCEMENT 2: Dedicated network coverage map with detailed coverage points"""
        self.add_page()
        self.chapter_title("NETWORK COVERAGE MAP - DETAILED ANALYSIS")
        
        network_data = route_data.get('network_coverage', {})
        
        if not network_data or not network_data.get('coverage_analysis'):
            no_data_content = """NETWORK COVERAGE MAP STATUS:
Network coverage analysis data is not available.

This could be due to:
* Route analysis performed without network coverage
* Network API services were not accessible
* Coverage data processing failed

RECOMMENDATIONS:
* Re-analyze route with network coverage enabled
* Check internet connectivity and API access
* Contact support if issue persists"""
            
            self.add_info_card("Network Coverage Map Unavailable", no_data_content, (255, 248, 220))
            return
        
        # Network coverage legend
        coverage_legend = """NETWORK COVERAGE MAP LEGEND:
[EXCELLENT] Dark Green: Excellent signal (>-70 dBm) - Full connectivity
[GOOD] Green: Good signal (-70 to -85 dBm) - Reliable connectivity  
[FAIR] Yellow: Fair signal (-85 to -100 dBm) - Adequate connectivity
[POOR] Orange: Poor signal (-100 to -110 dBm) - Unreliable connectivity
[DEAD] Red: No signal (<-110 dBm) - No connectivity
[FAILED] Gray: API failed - Coverage unknown

Each marker represents a real-time network coverage test point along your route.
Coverage data obtained from live cellular network APIs."""
        
        self.add_info_card("Network Coverage Map Legend", coverage_legend, (240, 255, 240))
        
        # Coverage statistics
        coverage_stats = network_data.get('coverage_stats', {})
        coverage_analysis = network_data.get('coverage_analysis', [])
        dead_zones = network_data.get('dead_zones', [])
        poor_zones = network_data.get('poor_zones', [])
        
        # Calculate detailed statistics
        quality_counts = coverage_stats.get('quality_distribution', {})
        api_success_rate = coverage_stats.get('api_success_rate', 0)
        overall_score = coverage_stats.get('overall_coverage_score', 0)
        
        coverage_stats_content = f"""NETWORK COVERAGE ANALYSIS RESULTS:
Total Points Tested: {len(coverage_analysis)}
API Success Rate: {api_success_rate:.1f}%
Overall Coverage Score: {overall_score:.1f}/100

SIGNAL QUALITY DISTRIBUTION:
* Excellent Coverage: {quality_counts.get('excellent', 0)} points
* Good Coverage: {quality_counts.get('good', 0)} points  
* Fair Coverage: {quality_counts.get('fair', 0)} points
* Poor Coverage: {quality_counts.get('poor', 0)} points
* Dead Zones: {quality_counts.get('dead', 0)} points
* API Failures: {quality_counts.get('api_failed', 0)} points

CRITICAL ALERTS:
* Confirmed Dead Zones: {len(dead_zones)} areas
* Poor Coverage Areas: {len(poor_zones)} areas

TECHNOLOGY AVAILABILITY:
* 5G Coverage: {coverage_stats.get('technology_availability', {}).get('5G', 0)} points
* 4G/LTE Coverage: {coverage_stats.get('technology_availability', {}).get('LTE', 0)} points
* 3G Coverage: {coverage_stats.get('technology_availability', {}).get('UMTS', 0)} points
* 2G Coverage: {coverage_stats.get('technology_availability', {}).get('GSM', 0)} points"""
        
        self.add_info_card("Network Coverage Statistics", coverage_stats_content)
        
        if api_key and coverage_analysis:
            # Create network coverage markers
            network_markers = self.create_network_coverage_markers(coverage_analysis, dead_zones, poor_zones)
            
            if network_markers:
                # Calculate center point
                center_lat = sum(marker['lat'] for marker in network_markers) / len(network_markers)
                center_lng = sum(marker['lng'] for marker in network_markers) / len(network_markers)
                
                self.set_font('Arial', 'B', 12)
                self.cell(0, 8, "[NETWORK MAP] REAL-TIME COVERAGE DATA WITH QUALITY MARKERS:", ln=True)
                self.ln(3)
                
                if self.add_static_map_image(center_lat, center_lng, network_markers, api_key, zoom=10, size="640x480"):
                    self.set_font('Arial', 'I', 10)
                    self.cell(0, 5, f"Network coverage map showing {len(network_markers)} real-time test points", ln=True, align='C')
                    
                    # Coverage quality breakdown
                    quality_breakdown = {}
                    for marker in network_markers:
                        quality = marker.get('coverage_quality', 'unknown')
                        quality_breakdown[quality] = quality_breakdown.get(quality, 0) + 1
                    
                    breakdown_text = "Coverage Quality: " + ", ".join([f"{k.title()}: {v}" for k, v in quality_breakdown.items()])
                    self.set_font('Arial', 'I', 8)
                    self.multi_cell(0, 4, breakdown_text, align='C')
        
        # Network coverage safety recommendations
        if dead_zones or poor_zones:
            self.ln(5)
            safety_recommendations = f"""NETWORK COVERAGE SAFETY RECOMMENDATIONS:

CRITICAL DEAD ZONES ({len(dead_zones)} areas):
* NO cellular coverage - Emergency calls impossible
* Download offline maps before departure
* Inform contacts of communication blackouts
* Consider satellite communication devices
* Travel with companions when possible

POOR COVERAGE ZONES ({len(poor_zones)} areas):
* Unreliable connectivity - Calls may drop
* Send location updates before entering these areas
* Keep devices fully charged
* Use WiFi calling when available
* Allow extra time for communications

GENERAL NETWORK SAFETY:
* Test your network provider's coverage along the route
* Carry portable chargers/power banks
* Download emergency contact numbers offline
* Consider multiple network providers if traveling frequently
* Know locations of cell towers along major routes"""
            
            self.add_info_card("Network Safety Recommendations", safety_recommendations, (255, 240, 245))

    def create_network_coverage_markers(self, coverage_analysis, dead_zones, poor_zones):
        """Create markers specifically for network coverage visualization"""
        markers = []
        
        # Color mapping for network quality
        quality_colors = {
            'excellent': 'darkgreen',
            'good': 'green', 
            'fair': 'yellow',
            'poor': 'orange',
            'dead': 'red',
            'api_failed': 'gray'
        }
        
        # Add coverage analysis points
        for i, point in enumerate(coverage_analysis):
            coords = point.get('coordinates', {})
            if isinstance(coords, dict) and 'lat' in coords and 'lng' in coords:
                quality = point.get('coverage_quality', 'unknown')
                color = quality_colors.get(quality, 'gray')
                
                markers.append({
                    'lat': coords['lat'],
                    'lng': coords['lng'],
                    'color': color,
                    'label': str(i + 1),
                    'type': 'network_coverage',
                    'coverage_quality': quality
                })
        
        # Highlight dead zones with special markers
        for i, zone in enumerate(dead_zones[:10], 1):  # Limit to 10
            coords = self.extract_coordinates(zone)
            if coords:
                markers.append({
                    'lat': coords['lat'],
                    'lng': coords['lng'],
                    'color': 'darkred',
                    'label': f'DEAD{i}',
                    'type': 'dead_zone',
                    'coverage_quality': 'dead'
                })
        
        return markers

    def extract_coordinates(self, zone_data):
        """Extract coordinates from various zone data formats"""
        if isinstance(zone_data, dict):
            # Try different coordinate keys
            for coord_key in ['coordinates', 'start_coordinates', 'location']:
                coords = zone_data.get(coord_key, {})
                if isinstance(coords, dict) and 'lat' in coords and 'lng' in coords:
                    return coords
        return None

    def calculate_safety_score(self, sharp_turns, dead_zones_count, poor_zones_count):
        """Calculate overall route safety score (0-100)"""
        base_score = 100
        
        # Deduct points for hazards
        blind_spots = len([t for t in sharp_turns if t.get('angle', 0) > 80])
        sharp_danger = len([t for t in sharp_turns if 70 <= t.get('angle', 0) <= 80])
        moderate_turns = len([t for t in sharp_turns if 45 <= t.get('angle', 0) < 70])
        
        # Deduct points based on severity
        base_score -= blind_spots * 15        # 15 points per blind spot
        base_score -= sharp_danger * 10       # 10 points per sharp turn
        base_score -= moderate_turns * 5      # 5 points per moderate turn
        base_score -= dead_zones_count * 8    # 8 points per dead zone
        base_score -= poor_zones_count * 4    # 4 points per poor coverage zone
        
        return max(0, min(100, base_score))

    def add_static_map_image(self, center_lat, center_lng, markers, api_key, zoom=15, size="640x480"):
        """Enhanced static map with better error handling and larger size"""
        try:
            base_url = "https://maps.googleapis.com/maps/api/staticmap"
            params = [
                f"center={center_lat},{center_lng}",
                f"zoom={zoom}",
                f"size={size}",
                "maptype=roadmap",
                "style=feature:poi|visibility:simplified",
                "style=feature:transit|visibility:off"
            ]
            
            # Add markers (limit to 50 for API constraints)
            for marker in markers[:50]:
                color = marker.get('color', 'red')
                label = marker.get('label', '')[:1]  # Single character only
                lat = marker.get('lat')
                lng = marker.get('lng')
                
                if lat and lng:
                    marker_param = f"markers=size:mid|color:{color}"
                    if label and label.isalnum():
                        marker_param += f"|label:{label}"
                    marker_param += f"|{lat},{lng}"
                    params.append(marker_param)
            
            params.append(f"key={api_key}")
            
            url = f"{base_url}?" + "&".join(params)
            response = requests.get(url, timeout=30)
            
            if response.status_code == 200 and len(response.content) > 1000:
                with tempfile.NamedTemporaryFile(delete=False, suffix='.png') as temp:
                    temp.write(response.content)
                    temp_path = temp.name
                
                # Enhanced image sizing
                current_y = self.get_y()
                available_height = 250 - current_y
                
                # Larger image for better visibility
                img_width = 170  # Wider image
                img_height = 120  # Taller image
                
                if available_height < img_height + 15:
                    self.add_page()
                    current_y = self.get_y()
                
                # Center the image
                x_position = (210 - img_width) / 2
                
                # Professional border
                self.set_draw_color(200, 200, 200)
                self.set_line_width(0.8)
                self.rect(x_position - 3, current_y - 3, img_width + 6, img_height + 6, 'D')
                
                # Add the image
                self.image(temp_path, x=x_position, y=current_y, w=img_width, h=img_height)
                
                # Clean up
                os.unlink(temp_path)
                
                # Move cursor below image
                self.set_y(current_y + img_height + 8)
                
                return True
            
            return False
        except Exception as e:
            print(f"Error adding static map: {e}")
            return False

    # Include other necessary methods from original PDF generator
    def add_risk_level_only(self, risk_segments):
        """Add only risk level text"""
        high = len([s for s in risk_segments if s.get('risk_level') == 'HIGH'])
        medium = len([s for s in risk_segments if s.get('risk_level') == 'MEDIUM'])
        low = len([s for s in risk_segments if s.get('risk_level') == 'LOW'])

        if high + medium + low == 0:
            high, medium, low = 3, 5, 10

        if high > 0:
            risk_level = "HIGH RISK"
            risk_message = "[WARNING] CRITICAL: This route contains high-risk segments requiring extreme caution."
            risk_color = self.danger_color
        elif medium > 0:
            risk_level = "MEDIUM RISK"
            risk_message = "[CAUTION] This route contains medium-risk segments requiring increased attention."
            risk_color = self.warning_color
        else:
            risk_level = "LOW RISK"
            risk_message = "[OK] SAFE: This route is generally low-risk with normal driving conditions."
            risk_color = self.success_color

        self.chapter_title("Overall Route Risk Level")
        
        self.set_font('Arial', 'B', 18)
        self.set_text_color(*risk_color)
        self.cell(0, 12, f"RISK LEVEL: {risk_level}", 0, 1, 'C')
        self.set_text_color(0, 0, 0)
        self.ln(5)
        
        self.set_font('Arial', 'B', 12)
        self.cell(0, 8, "Risk Segment Breakdown:", ln=True)
        self.set_font('Arial', '', 11)
        breakdown_text = f"""High Risk Segments: {high}
Medium Risk Segments: {medium}
Low Risk Segments: {low}
Total Segments Analyzed: {high + medium + low}"""
        
        self.multi_cell(0, 6, breakdown_text)
        self.ln(5)
        
        self.add_info_card("Risk Assessment Summary", risk_message, 
                          (255, 240, 240) if high > 0 else (255, 248, 220) if medium > 0 else (240, 255, 240))


# UPDATED MAIN FUNCTION WITH ALL ENHANCEMENTS
def generate_pdf(filename, from_addr, to_addr, distance, duration, turns, petrol_bunks,
                hospital_list, schools=None, food_stops=None, police_stations=None, 
                elevation=None, weather=None, risk_segments=None, compliance=None,
                emergency=None, environmental=None, toll_gates=None, bridges=None, 
                vehicle_type="car", type="full", api_key=None, major_highways=None, route_data=None):
    """
    ENHANCED PDF GENERATION WITH COMPREHENSIVE MAPPING
    """
    
    # Handle None values
    if not schools: schools = {}
    if not food_stops: food_stops = {}
    if not police_stations: police_stations = {}
    if not elevation: elevation = []
    if not weather: weather = []
    if not risk_segments: risk_segments = []
    if not toll_gates: toll_gates = []
    if not bridges: bridges = []
    if not major_highways: major_highways = []
    if not turns: turns = []
    if not route_data: route_data = {}
    
    # Convert data formats
    enhanced_turns = []
    if turns:
        for turn in turns:
            if isinstance(turn, dict) and all(k in turn for k in ['lat', 'lng', 'angle']):
                enhanced_turns.append(turn)
            elif isinstance(turn, (list, tuple)) and len(turn) >= 3:
                enhanced_turns.append({'lat': turn[0], 'lng': turn[1], 'angle': turn[2]})
    
    # Create PDF
    pdf = RoutePDF("Enhanced Route Safety Analysis - Comprehensive Maps & Network Coverage")
    pdf.alias_nb_pages()
    
    # 1. TITLE PAGE
    pdf.add_title_page()

    # 2. ROUTE OVERVIEW
    pdf.add_page()
    pdf.add_section("Route Overview", 
        f"From: {from_addr}\n"
        f"To: {to_addr}\n"
        f"Distance: {distance}\n"
        f"Estimated Duration: {duration}\n"
        f"Vehicle Type: {vehicle_type.replace('_', ' ').title()}\n"
        f"Report Type: {type.replace('_', ' ').title()}\n"
        f"Analysis Date: {datetime.datetime.now().strftime('%B %d, %Y at %I:%M %p')}"
    )
    
    # 3. ENHANCEMENT 1: COMPREHENSIVE ROUTE MAP WITH ALL POINTS
    pdf.add_comprehensive_route_map(route_data, api_key)
    
    # 4. ENHANCEMENT 2: DEDICATED NETWORK COVERAGE MAP
    pdf.add_dedicated_network_coverage_map(route_data, api_key)
    
    # 5. OVERALL ROUTE RISK LEVEL
    pdf.add_page()
    pdf.add_risk_level_only(risk_segments)
    
    # Save PDF
    try:
        pdf.output(filename)
        print(f"Enhanced PDF report with comprehensive maps generated successfully: {filename}")
        return filename
    except Exception as e:
        print(f"Error generating enhanced PDF: {e}")
        return None